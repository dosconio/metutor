// Device\ST\STM32MP13xx\Source\Templates\system_stm32mp13xx_A7.c
// PART OF IT FROM ST-Microelectronics
// MORE TO GO https://stmcu.com.cn/
// ! This is not ST-Official File

#include "stm32mp13xx.h"
#include "irq_ctrl.h"
#include "math.h"

#if defined ( __ICCARM__ )
extern uint32_t ZI_DATA;
extern uint32_t __BSS_END__;
extern  IRQHandler_t IRQ_Vector_Table[MAX_IRQ_n];
extern void ZeroBss( void );
#endif


/************************* Miscellaneous Configuration ************************/
/*!< Uncomment the following line if you need to use external SRAM mounted
     on EVAL board as data memory  */


/* This defines are associated to GICv2 IP from ARM */
#define GIC_HIGHEST_INTERRUPT_VALUE 1020U
#define GIC_HIGHEST_SGI_PPI_VALUE     31U
#define GIC_HIGHEST_SGI_VALUE         15U

/*
 * ID 1023. This value is returned to a processor, in response to an interrupt acknowledge,
 * if there is no pending interrupt with sufficient priority for
 * it to be signaled to the processor.
 */
#define GIC_ACKNOWLEDGE_RESPONSE 1023U

/*  GICC_IAR bit assignments
 * [31:13] - Reserved.
 * [12:10] CPUID For SGIs in a multiprocessor implementation, this field identifies the processor that
 * requested the interrupt. It returns the number of the CPU interface that made the
 * request, for example a value of 3 means the request was generated by a write to the
 * GICD_SGIR on CPU interface 3.
 * For all other interrupts this field is RAZ.
 * [9:0] Interrupt ID The interrupt ID
 */
#define GICC_IAR_VALID_BITMASK    0x3FF
#define GICC_IAR_CPU_ID_BITMASK  0x1C00
#define GICC_IAR_CPU_ID_SHIFT        10

#define __GIC_GET_CPU_ID(__IAR)  (((__IAR) & GICC_IAR_CPU_ID_BITMASK) >> GICC_IAR_CPU_ID_SHIFT)

#if defined (DATA_IN_ExtSRAM)
  static void SystemInit_ExtMemCtl(void);
#endif /* DATA_IN_ExtSRAM */

static void SystemInit_IRQ_ErrorHandler(void)
{
#if !defined(USE_SECOND_A7_CORE)
  /* Behavior in case of Exception or IRQ handling Errors */
  while(1U);
#endif
}

__weak void SystemInit_Interrupts_SoftIRQn_Handler(uint32_t Software_Interrupt_Id, uint8_t cpu_id_request)
{
  /* Prevent unused argument(s) compilation warning */
  UNUSED((void)Software_Interrupt_Id);
  UNUSED((void)cpu_id_request);
}

void SecurePhysicalTimer_hand(void)
{
  IRQ_ClearPending((IRQn_ID_t)SecurePhyTimer_IRQn);

#if 0
/* Simple version
   same as ARM CMSIS-Core-A for RTX OS

   Doesn't compensate for IRQ processing time (hardware and software)

   Measured error with non optimized compilation (-O0) is
     193 CLK/tick = 193/48000 = 0.40 % = 4ms/s
   Measured error with optimized compilation (-O2) is
     110 CLK/tick = 110/48000 = 0.23 % = 2.3ms/s
*/

  PL1_SetLoadValue(HSI_VALUE/1000);
#endif /* 0 */

#if 0
/* Assembly version
   Best result whatever optimization used for compilation

   Compensates for IRQ processing time (hardware and software) by adding current counter value
     which decrements below 0 after IRQ trigger and thus contains -(time since IRQ triggered)
   As if is basic assembly, it is not semsitive to optimization setting

   Measured error with non optimized compilation (-O0) is
     6 CLK/tick = 6/48000 = 0.01 % = 0.1ms/s
   Measured error with optimized compilation (-O2) is
     6 CLK/tick = 6/48000 = 0.01 % = 0.1ms/s
*/

  __ASM volatile("MRC p15, 0, r3, c14, c2, 0\n"
                 "ADD r3, r3, #47872\n"
                 "ADD r3, r3, #128\n"
                 "MCR p15, 0, r3, c14, c2, 0":::"r3");
#endif /* 0 */

/* C version with IRQ processing time compensation.
   Same method as assembly version but written in C using CMSIS-Core-A API.

   Same result as Assembly version when optimized because functions are inlined and generated code is same as assembly version
   Result is not good when not optimized because "inline" functions are not inlined by GCC when optimization is off.
     So time for functions calls between Counter read and counter write are not compensated

   Compensates for IRQ processing time (hardware and software) by adding current counter value
     which decrements below 0 after IRQ trigger and thus contains -(time since IRQ triggered)

   Measured error with non optimized compilation (-O0) is
     34 CLK/tick = 34/48000 = 0.07 % = 0.7ms/s
   Measured error with optimized compilation (-O2) is
     6 CLK/tick = 6/48000 = 0.01 % = 0.1ms/s
*/

  PL1_SetLoadValue((HSI_VALUE/1000U) + PL1_GetCurrentValue());

  //{TODO} HAL_IncTick();
}
/**
  * @brief  Generic IRQ Handler (Software IRQs, PPIs & IRQs)
  * @param  None
  * @retval None
  */
#if defined ( __GNUC__ )
#pragma GCC push_options
#pragma GCC target("general-regs-only")
void __attribute__ ((interrupt ("IRQ")))IRQ_Handler(void) {
#elif defined ( __ICCARM__ )
	__irq __arm void IRQ_Handler(void) {
#endif
	  uint32_t ItId;
	  IRQHandler_t handler;

	  while (1U)
	  {
	    /* Get highest pending Interrupt Id from GIC driver*/
	    ItId = (uint32_t)IRQ_GetActiveIRQ();

	    if (ItId <= GIC_HIGHEST_INTERRUPT_VALUE) /* Highest value of GIC Valid Interrupt */
	    {
	      /* Check validity of IRQ */
	      if (ItId >= (uint32_t)MAX_IRQ_n)
	      {
	        SystemInit_IRQ_ErrorHandler();
	      }
	      else
	      {
	        /* Find appropriate IRQ Handler (Require registration before!) */
	        handler = IRQ_GetHandler((IRQn_ID_t)ItId);

	        if (handler!=NULL)
	        {
	          /* Call IRQ Handler */
	          handler();
	        }
	        else
	        {
	          /* Un register Handler , error ! */
	          SystemInit_IRQ_ErrorHandler();
	        }
	      }

	      /* End Acknowledge interrupt */
	      IRQ_EndOfInterrupt((IRQn_ID_t)ItId);
	    }
	    else
	    {
	      /* Normal case: whenever there is no more pending IRQ , IAR returns ACKNOWLEDGE special IRQ value */
	      if (ItId == GIC_ACKNOWLEDGE_RESPONSE)
	      {
	        break;
	      }
	      /* Spurious IRQ Value (1022)  ... */
	      else
	      {
	        SystemInit_IRQ_ErrorHandler();
	      }
	    }
	  }
	}
#ifdef __GNUC__
#pragma GCC pop_options
#endif
/**
  * @brief  Ensure all bss part of code is initialized with zeros
  * @param  None
  * @retval None
  */
#if defined ( __GNUC__ )
void __attribute__((noinline)) ZeroBss(void)
{
  __asm volatile(
    "PUSH {R4-R11}          \n"
    "LDR r2, =ZI_DATA       \n"
    "b LoopFillZerobss      \n"
    /* Zero fill the bss segment. */
    "FillZerobss:           \n"
    "MOVS r3, #0            \n"
    "STR  r3, [r2]          \n"
    "adds r2, r2, #4        \n"

    "LoopFillZerobss:       \n"
    "LDR r3, = __BSS_END__  \n"
    "CMP r2, r3             \n"
    "BCC FillZerobss        \n"

    "DSB                    \n"
    "POP    {R4-R11}        "
  );
}
#endif



void MP13_SystemInit(void)
{

#if !defined ( __ICCARM__ )
  /* Fill BSS Section with '0' */
  ZeroBss();
#endif

  /* Invalidate entire Unified TLB */
  MMU_InvalidateTLB();

  /* Disable all interrupts and events */
  CLEAR_REG(EXTI_C1->IMR1);
  CLEAR_REG(EXTI_C1->IMR2);
  CLEAR_REG(EXTI_C1->IMR3);
  CLEAR_REG(EXTI_C1->EMR1);
  CLEAR_REG(EXTI_C1->EMR2);
  CLEAR_REG(EXTI_C1->EMR3);

  /* Invalidate entire branch predictor array */
  L1C_InvalidateBTAC();

  /*  Invalidate instruction cache and flush branch target cache */
  L1C_InvalidateICacheAll();

  /*  Invalidate data cache */
  L1C_InvalidateDCacheAll();

#if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
  /* Enable FPU */
  __FPU_Enable();
#endif

#ifdef MMU_USE
  /* Create Translation Table */
  MMU_CreateTranslationTable();

  /* Enable MMU */
  MMU_Enable();
#endif

  /* Enable Caches */
#ifdef CACHE_USE
  L1C_EnableCaches();
#endif
  L1C_EnableBTAC();

#if (__GIC_PRESENT == 1)
  uint32_t i;

  /* Enable GIC */
  IRQ_Initialize();

#endif
}

/**
 * @brief  Setup the microcontroller system
 *         Initialize the FPU setting, vector table location and External memory
 *         configuration for Cortex-A7 cpu1.
 * @param  None
 * @retval None
 */
void SystemInit_cpu1 (void)
{
  /* Invalidate entire Unified TLB */
  MMU_InvalidateTLB();

  /* Invalidate entire branch predictor array */
  L1C_InvalidateBTAC();

  /*  Invalidate instruction cache and flush branch target cache */
  L1C_InvalidateICacheAll();

  /*  Invalidate data cache */
  L1C_InvalidateDCacheAll();

#if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
  /* Enable FPU */
  __FPU_Enable();
#endif

#ifdef MMU_USE
  /* Create Translation Table */
  MMU_CreateTranslationTable();

  /* Enable MMU */
  MMU_Enable();
#endif

 /* Enable Caches */
#ifdef CACHE_USE
  L1C_EnableCaches();
#endif
  L1C_EnableBTAC();

}
